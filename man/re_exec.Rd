% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/exec.R, R/exec-all.R, R/indexing.R
\name{re_exec}
\alias{re_exec}
\alias{re_exec_all}
\alias{$.rematch_records}
\alias{$.rematch_allrecords}
\title{Extract Regular Expression Matches and Match Positions Into a Data Frame}
\usage{
re_exec(text, pattern, perl = TRUE, ...)

re_exec_all(text, pattern, perl = TRUE, ...)

\method{$}{rematch_records}(x, name)

\method{$}{rematch_allrecords}(x, name)
}
\arguments{
\item{text}{Character vector.}

\item{pattern}{A regular expression. See \code{\link[base]{regex}} for more
about regular expressions.}

\item{perl}{logical should perl compatible regular expressions be used?
Defaults to TRUE, setting to FALSE will disable capture groups.}

\item{...}{Additional arguments to pass to
\code{\link[base]{gregexpr}} (or \code{\link[base]{regexpr}} if
\code{text} is of length zero).}

\item{x}{Object returned by \code{re_exec} or \code{re_exec_all}.}

\item{name}{\code{match}, \code{start} or \code{end}.}
}
\value{
A tidy data frame (see Section \dQuote{Tidy Data}).  Each match data
  column list contains match records, one for each element in \code{text}.  A
  match record is a named list, with entries \code{match}, \code{start} and
  \code{end} that are respectively the matching (sub) string, the start, and
  the end positions (using one based indexing).  For \code{re_exec} these
  entries will be one length vectors set to NA if there is no match.  For
  \code{re_exec_all} these will be vectors as long as the number of
  matches within each input vector element.
}
\description{
Match a regular expression to a string, and return matches, match positions,
and capture groups.  These functions are like their
\code{\link[=re_match]{*_match}} counterparts, except they return
match/capture group start and end positions in addition to the matched
values.
}
\details{
\code{re_exec} returns the data from the first match, while
\code{re_exec_all} returns the data from all matches. The functions use
\code{\link[base]{regexpr}} and \code{\link[base]{gregexpr}} respectively to
extract matching substring(s) for a regular expression.
}
\section{Tidy Data}{
 The return value is a tidy data frame where each row
corresponds to an element of the input character vector \code{text}.  The
values from \code{text} appear for reference in the \code{.text} character
column.  All other columns are list columns containing the match data.  The
\code{.match} column contains the match information for full regular
expression matches while other columns correspond to capture groups if there
are any, and PCRE matches are enabled with \code{perl = TRUE} (this is on by
default).  If capture groups are named the corresponding columns will bear
those names.
}

\section{Extracting Match Data}{
 To make it easier to extract matching
substrings or positions, a special \code{$} operator is defined on match
columns, both for the \code{.match} column and the columns corresponding to
the capture groups.  See examples below.
}

\examples{
name_rex <- paste0(
  "(?<first>[[:upper:]][[:lower:]]+) ",
  "(?<last>[[:upper:]][[:lower:]]+)"
)
notables <- c(
  "  Ben Franklin and Jefferson Davis",
  "\\tMillard Fillmore"
)
# Match first occurrence
pos <- re_exec(notables, name_rex)
pos

# All occurrences
allpos <- re_exec_all(notables, name_rex)
allpos

# Custom $ to extract matches and positions
pos$first$match
pos$first$start
pos$first$end
allpos$first$match
allpos$first$start
allpos$first$end
}
\seealso{
Other tidy regular expression matching: \code{\link{re_match_all}},
  \code{\link{re_match}}
}
